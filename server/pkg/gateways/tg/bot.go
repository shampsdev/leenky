package tg

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"strings"
	"time"

	"github.com/go-telegram/bot"
	"github.com/go-telegram/bot/models"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/shampsdev/tglinked/server/cmd/config"
	"github.com/shampsdev/tglinked/server/pkg/repo"
	"github.com/shampsdev/tglinked/server/pkg/usecase"
	"github.com/shampsdev/tglinked/server/pkg/utils/slogx"
)

type Bot struct {
	*bot.Bot
	cases usecase.Cases
	log   *slog.Logger

	botUrl    string
	webAppUrl string

	supergroupDelay time.Duration
}

func NewBot(ctx context.Context, cfg *config.Config, pool *pgxpool.Pool) (*Bot, error) {
	opts := []bot.Option{}

	if cfg.Debug {
		opts = append(opts, bot.WithDebug())
	}
	tgb, err := bot.New(cfg.TG.BotToken, opts...)
	if err != nil {
		return nil, fmt.Errorf("error creating bot: %w", err)
	}
	cases := usecase.Setup(ctx, cfg, pool, tgb)

	b := &Bot{
		Bot:   tgb,
		cases: cases,
		log:   slogx.FromCtx(ctx),

		supergroupDelay: 5 * time.Second,
	}

	me, err := b.GetMe(context.Background())
	if err != nil {
		return nil, fmt.Errorf("error getting bot info: %w", err)
	}
	b.webAppUrl = fmt.Sprintf("https://t.me/%s/%s", me.Username, cfg.TG.WebAppName)
	b.botUrl = fmt.Sprintf("https://t.me/%s", me.Username)

	return b, nil
}

func (b *Bot) Run(ctx context.Context) {
	_, err := b.SetMyCommands(ctx, &bot.SetMyCommandsParams{
		Commands: []models.BotCommand{},
	})
	if err != nil {
		panic(fmt.Errorf("error setting bot commands: %w", err))
	}

	b.RegisterHandlerMatchFunc(func(update *models.Update) bool {
		return update.MyChatMember != nil
	}, b.handleMyChatMember)

	b.RegisterHandler(bot.HandlerTypeMessageText, "/register", bot.MatchTypePrefix, b.handleCommandRegister)
	b.RegisterHandler(bot.HandlerTypeMessageText, "/start", bot.MatchTypeExact, b.handleCommandStart)
	b.RegisterHandler(bot.HandlerTypeMessageText, "/link", bot.MatchTypeExact, b.handleCommandLink)
	b.RegisterHandler(bot.HandlerTypeMessageText, "/connect", bot.MatchTypePrefix, b.handleCommandConnect)

	b.RegisterHandlerMatchFunc(func(update *models.Update) bool {
		return update.Message != nil && update.Message.MigrateFromChatID != 0
	}, b.handleMigrate)

	b.RegisterHandlerMatchFunc(func(update *models.Update) bool {
		return update.Message != nil &&
			(len(update.Message.NewChatPhoto) != 0 || update.Message.NewChatTitle != "" || update.Message.DeleteChatPhoto)
	}, b.handleChatChanged)

	b.Start(ctx)
}

func (b *Bot) handleCommandRegister(ctx context.Context, _ *bot.Bot, update *models.Update) {
	chatMember, err := b.GetChatMember(ctx, &bot.GetChatMemberParams{
		ChatID: update.Message.Chat.ID,
		UserID: update.Message.From.ID,
	})
	log := b.log.With("chat_id", update.Message.Chat.ID, "user_id", update.Message.From.ID)

	if err != nil {
		slogx.WithErr(log, err).Error("error getting chat member")
		return
	}
	if chatMember.Administrator == nil && chatMember.Owner == nil {
		_, err := b.SendMessage(ctx, &bot.SendMessageParams{
			ChatID: update.Message.Chat.ID,
			Text:   "–ö–æ–º–∞–Ω–¥–∞ /register –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º ü§®",
		})
		if err != nil {
			slogx.WithErr(log, err).Error("error sending message")
		}
		return
	}

	msg := update.Message
	if msg.Chat.Type != models.ChatTypeGroup && msg.Chat.Type != models.ChatTypeSupergroup {
		_, err := b.SendMessage(ctx, &bot.SendMessageParams{
			ChatID:    update.Message.Chat.ID,
			Text:      "–ö–æ–º–∞–Ω–¥–∞ `/register` –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ —á–∞—Ç–∞—Ö, –ø–æ—Å–∫–æ—Ä–µ–µ –¥–æ–±–∞–≤—å –º–µ–Ω—è —Ç—É–¥–∞ üëÅÔ∏èü´¶üëÅÔ∏è",
			ParseMode: models.ParseModeMarkdown,

			ReplyMarkup: &models.InlineKeyboardMarkup{
				InlineKeyboard: [][]models.InlineKeyboardButton{
					{
						{
							Text: "‚≠êÔ∏è –î–æ–±–∞–≤–∏—Ç—å –≤ —á–∞—Ç",
							URL:  fmt.Sprintf("%s?startgroup=", b.botUrl),
						},
					},
				},
			},
		})
		if err != nil {
			slogx.WithErr(log, err).Error("error sending message")
		}
		return
	}
	err = b.registerChat(ctx, msg.Chat.ID)
	if err != nil {
		slogx.WithErr(log, err).Error("error registering chat")
	}
}

func (b *Bot) handleCommandStart(ctx context.Context, _ *bot.Bot, update *models.Update) {
	_, err := b.SendMessage(ctx, &bot.SendMessageParams{
		ChatID: update.Message.Chat.ID,
		Text: `*–ö–∞–∫ –Ω–∞—á–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è Leenky?*

1\. –û—Ç–∫—Ä–æ–π—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
2\. –ó–∞–ø–æ–ª–Ω–∏—Ç–µ —Å–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å 
3\. –î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ —á–∞—Ç

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ *–∫–æ–º–∞–Ω–¥—ã* –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–æ–º –≤ —á–∞—Ç–µ\. –î–ª—è —ç—Ç–æ–≥–æ –Ω–∞–ø–∏—à–∏—Ç–µ "/" –≤ –Ω—É–∂–Ω—ã–π —á–∞—Ç –∏ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É –∏–∑ –æ—Ç–∫—Ä—ã–≤—à–µ–≥–æ—Å—è —Å–ø–∏—Å–∫–∞\.`,
		ParseMode: models.ParseModeMarkdown,
		ReplyMarkup: &models.InlineKeyboardMarkup{
			InlineKeyboard: [][]models.InlineKeyboardButton{
				{
					{
						Text: "‚≠êÔ∏è –û—Ç–∫—Ä—ã—Ç—å",
						URL:  b.webAppUrl,
					},
					{
						Text: "‚≠êÔ∏è –î–æ–±–∞–≤–∏—Ç—å –≤ —á–∞—Ç",
						URL:  fmt.Sprintf("%s?startgroup=", b.botUrl),
					},
				},
			},
		},
	})
	if err != nil {
		slogx.FromCtxWithErr(ctx, err).Error("error sending message")
	}
}

func (b *Bot) handleCommandLink(ctx context.Context, _ *bot.Bot, update *models.Update) {
	tgChatID := update.Message.Chat.ID
	log := slogx.FromCtx(ctx).With("tg_chat_id", tgChatID)
	chat, err := b.cases.Community.GetPreviewByTGID(ctx, tgChatID)
	if err != nil {
		log.Error("error getting chat", slogx.Err(err))
		return
	}
	log = log.With("chat_id", chat.ID)

	_, err = b.SendMessage(ctx, &bot.SendMessageParams{
		ChatID:    tgChatID,
		Text:      fmt.Sprintf("–ü–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ –º–æ–∂–Ω–æ –≤—Å—Ç—É–ø–∏—Ç—å –≤ –Ω–∞—à–µ –∫–æ–º—å—é–Ω–∏—Ç–∏ <b>%s</b>!\n üëâ %s üëà", chat.Name, b.urlForChat(chat.ID)),
		ParseMode: models.ParseModeHTML,
	})
	if err != nil {
		log.Error("error sending message", slogx.Err(err))
	}
}

func (b *Bot) handleMyChatMember(ctx context.Context, _ *bot.Bot, update *models.Update) {
	mcm := update.MyChatMember
	log := slogx.FromCtx(ctx).With("tg_chat_id", mcm.Chat.ID)

	if !(mcm.NewChatMember.Type == models.ChatMemberTypeBanned || mcm.NewChatMember.Type == models.ChatMemberTypeLeft) {
		// if bot wasn't in chat
		if mcm.OldChatMember.Type == models.ChatMemberTypeLeft ||
			mcm.OldChatMember.Type == models.ChatMemberTypeBanned {

			// if chat is supergroup, there is a change, that it migrated from known chat
			// so we need to wait for possible migrate event
			if mcm.Chat.Type == models.ChatTypeSupergroup {
				go func() {
					log.Info("waiting for migrate event")
					time.Sleep(b.supergroupDelay)

					_, err := b.cases.Community.GetPreviewByTGID(ctx, mcm.Chat.ID)

					if errors.Is(err, repo.ErrNotFound) {
						log.Info("chat not found, registering chat")
						err := b.registerChat(ctx, mcm.Chat.ID)
						if err != nil {
							log.With(slogx.Err(err)).Error("error registering chat")
						}
						return
					}

					if err != nil {
						log.With(slogx.Err(err)).Error("error getting chat")
						return
					}
					log.Info("chat found, not registering chat")
				}()
				return
			}

			err := b.registerChat(ctx, mcm.Chat.ID)
			if err != nil {
				log.With(slogx.Err(err)).Error("error registering chat")
			}
		}
	}
}

func (b *Bot) handleCommandConnect(ctx context.Context, _ *bot.Bot, update *models.Update) {
	msg := update.Message
	log := slogx.FromCtx(ctx).With("tg_chat_id", msg.Chat.ID, "tg_chat_title", msg.Chat.Title)
	communityID := strings.TrimPrefix(msg.Text, "/connect ")
	err := b.cases.Community.ConnectCommunityWithTGChat(ctx, msg.From.ID, communityID, msg.Chat.ID)
	if err != nil {
		log.With(slogx.Err(err)).Error("error connecting chat")
		_, err = b.SendMessage(ctx, &bot.SendMessageParams{
			ChatID: msg.Chat.ID,
			Text: `–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å —á–∞—Ç –∫ –≤–∞—à–µ–º—É –∫–æ–º—å—é–Ω–∏—Ç–∏ üò¢
- –ú–æ–∂–µ—Ç –±—ã—Ç—å –≤—ã –Ω–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä?
- –ê –º–æ–∂–µ—Ç —á–∞—Ç —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω?`,
		})
		if err != nil {
			log.With(slogx.Err(err)).Error("error sending message")
		}
		return
	}
	log.Info("chat connected")

	_, err = b.SendMessage(ctx, &bot.SendMessageParams{
		ChatID: msg.Chat.ID,
		Text:   "–ß–∞—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ –≤–∞—à–µ–º—É –∫–æ–º—å—é–Ω–∏—Ç–∏ üéâ",
	})
	if err != nil {
		log.With(slogx.Err(err)).Error("error sending message")
	}
	err = b.registerChat(ctx, msg.Chat.ID)
	if err != nil {
		log.With(slogx.Err(err)).Error("error sending message")
	}
}

func (b *Bot) handleMigrate(ctx context.Context, _ *bot.Bot, update *models.Update) {
	fromChatID := update.Message.MigrateFromChatID
	toChatID := update.Message.Chat.ID

	err := b.cases.Community.MigrateTGChatID(ctx, fromChatID, toChatID)
	if err != nil {
		slogx.FromCtxWithErr(ctx, err).Error("error changing chat telegram id")
	}
	slogx.Info(ctx, "chat migrated", "from", fromChatID, "to", toChatID)
}

func (b *Bot) handleChatChanged(ctx context.Context, _ *bot.Bot, update *models.Update) {
	err := b.cases.Community.SyncCommunityWithTGChat(ctx, update.Message.Chat.ID)
	if err != nil {
		slogx.FromCtxWithErr(ctx, err).Error("error syncing community with tg chat")
		return
	}

	_, err = b.SendMessage(ctx, &bot.SendMessageParams{
		ChatID: update.Message.Chat.ID,
		Text:   "–û, —É –≤–∞—Å —Ç—É—Ç –ø–µ—Ä–µ–º–µ–Ω—ã? –ó–∞–ø–æ–º–Ω–∏–ª üòâ",
	})
	if err != nil {
		slogx.FromCtxWithErr(ctx, err).Error("error sending message")
	}
}

func (b *Bot) registerChat(ctx context.Context, chatID int64) error {
	community, err := b.cases.Community.GetPreviewByTGID(ctx, chatID)
	if err != nil {
		return fmt.Errorf("error getting chat: %w", err)
	}

	msg, err := b.SendPhoto(ctx, &bot.SendPhotoParams{
		ChatID: *community.TGChatID,
		Photo: &models.InputFileString{
			Data: "https://s3.ru1.storage.beget.cloud/f5732312921d-shampsdev/tglinked/assets/joinchat.jpg",
		},
		Caption: `*–ü—Ä–∏–≤–µ—Ç, —ç—Ç–æ Leenky ‚Äî –≤–∞—à–∞ —Å–µ—Ç—å –ø–æ–ª–µ–∑–Ω—ã—Ö –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤\!* üëã

–Ø –ø–æ–º–æ–≥—É –≤–∞–º –ª—É—á—à–µ —É–∑–Ω–∞—Ç—å –ª—é–¥–µ–π –≤ —ç—Ç–æ–º —á–∞—Ç–µ\! –†–∞—Å—Å–∫–∞–∂–∏—Ç–µ –æ —Å–µ–±–µ –∏ —Ä–∞—Å—à–∏—Ä—å—Ç–µ –∫—Ä—É–≥ –ø–æ–ª–µ–∑–Ω—ã—Ö –∑–Ω–∞–∫–æ–º—Å—Ç–≤\.

–ß—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –±–æ–ª—å—à–µ –æ–± —É—á–∞—Å—Ç–Ω–∏–∫–∞—Ö —á–∞—Ç–∞, –æ—Ç–∫—Ä–æ–π—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø–æ –∫–Ω–æ–ø–∫–µ –Ω–∏–∂–µ\.

*–ù–µ –∑–∞–±—É–¥—å—Ç–µ –∑–∞–∫—Ä–µ–ø–∏—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ* üìå`,
		ParseMode: models.ParseModeMarkdown,
		ReplyMarkup: models.InlineKeyboardMarkup{
			InlineKeyboard: [][]models.InlineKeyboardButton{{{
				Text: "–û—Ç–∫—Ä—ã—Ç—å",
				URL:  b.urlForChat(community.ID),
			}}},
		},
	})
	if err != nil {
		return fmt.Errorf("error sending message: %w", err)
	}

	_, err = b.PinChatMessage(ctx, &bot.PinChatMessageParams{
		ChatID:    *community.TGChatID,
		MessageID: msg.ID,
	})
	if err != nil {
		return fmt.Errorf("error pinning message: %w", err)
	}

	return nil
}

func (b *Bot) urlForChat(chatID string) string {
	return fmt.Sprintf("%s?startapp=%s", b.webAppUrl, chatID)
}
